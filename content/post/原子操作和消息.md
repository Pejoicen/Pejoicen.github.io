---
title: "原子操作和事件"
date: 2019-08-20T14:23:10+08:00
description: ""
draft: false
tags: ["线程","进程","Windows"]
categories: ["C/C++"]
---

整理Windows MFC编程中用到的原子操作和事件。  


<!--more-->

# 原子操作

"原子操作(atomic operation)是不需要synchronized"，这是多线程编程的老生常谈了。
所谓原子操作是指不会被线程调度机制打断的操作；
这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。

## CCriticalSection 
类CCriticalSection的对象表示一个“临界区”，它是一个用于同步的对象，同一时刻只允许一个线程存取资源或代码区。  临界区在控制一次只有一个线程修改数据或其它的控制资源时非常有用。
例如，在链表中增加一个结点就只允许一次一个线程进行。通过使用CCriticalSection对象来控制链表，就可以达到这个目的。
在运行性能比较重要而且资源不会跨进程使用时，建议采用临界区代替信号灯。有关在MFC中使用信号灯的详细信息，请参阅CMutex。

使用CCriticalSection对象之前，需要构造它。在构造函数返回后，就可以使用临界区了。在使用完之后要调用UnLock函数。存取由CCriticalSection控制的资源时，要在资源的存取函数中定义一个CSingleLock型的变量。然后调用加锁对象的Lock成员函数（如CSingleLock::Lock）。
此时，调用的线程要么获得对资源的存取权，要么等待他人释放资源等待加锁，或者等待他人释放资源，但又因为超时而加锁失败。
这样就**保证了一次只有一个线程在存取临界资源**。释放资源只需调用成员函数UnLock（例如CSingleLock::Unlock），或让锁对象在作用范围之外。此外，可以单独地建立一个CCriticalSection对象，并在存取临界资源之前显式地存取它。
这种方式有助于保持代码的清晰，但是更容易出错，因为程序员要记住在存取临界资源前加锁，存取之后开锁。
使用时必须包含头文件#include "afxmt.h"

```cpp
#include "afxmt.h"
CCriticalSection g_InsertRcvDataInfoCriticalSection;

void InsertRcvDataInfoToTeam(BYTE *pRcvDataBuf,int nBytes)
{
    //使用临界区加锁
    g_InsertRcvDataInfoCriticalSection.Lock();

    while(isRcvDataInfoTeamFull())
    {
        Sleep(10);
    }

    memcpy(g_RcvDataInfoTeamIn->RcvDataBuf,pRcvDataBuf,nBytes);
    g_RcvDataInfoTeamIn->RcvDataLenInBytes = nBytes;

    if(g_RcvDataInfoTeamIn == (g_RcvDataInfoTeam + MAX_RCVDATA_INFO_ITEMS - 1))
        g_RcvDataInfoTeamIn = g_RcvDataInfoTeam;
    else
        g_RcvDataInfoTeamIn++;

    g_pMainView->PostMessage(WM_DISPLAY_INFO,2,0);

    // 临界区解锁
    g_InsertRcvDataInfoCriticalSection.Unlock();
}

// 当两个线程都调用InsertRcvDataInfoToTeam函数时，临界区内的内容同一时间只有一个线程访问。一个线程执行代码时，如果发现g_InsertRcvDataInfoCriticalSection.Lock()处于lock状态，则会在这里等待。
```

CCriticalSection类定义：  
```cpp
/////////////////////////////////////////////////////////////////////////////
// CCriticalSection

class CCriticalSection : public CSyncObject
{
    DECLARE_DYNAMIC(CCriticalSection)

private:
   using CSyncObject::Unlock;

// Constructor
public:
    CCriticalSection();

// Attributes
public:
    operator CRITICAL_SECTION*();
    CRITICAL_SECTION m_sect;

// Operations
public:
    BOOL Unlock();
    BOOL Lock();
    BOOL Lock(DWORD dwTimeout);

// Implementation
public:
    virtual ~CCriticalSection();

private:
    BOOL Init();
};
```

## CMutex
(待补充)


# 事件

事件是很常用的多线程同步互斥机制



## 举例
```cpp
HANDLE g_hTMFrameSampleThreadExitEvent[NUM_OF_CARDS];

// 初始化
void InitParamVal()
{
    //所有事件赋初值INVALID_HANDLE_VALUE
    for(int i = 0; i < NUM_OF_CARDS; i++)
    {
        // TM采样线程事件
        g_hTMFrameSampleThreadExitEvent[i] = INVALID_HANDLE_VALUE;
    }
}

//开始启动所有线程
void StartServerListenThread(CWnd *pWnd)
{
    for(int i = 0; i < NUM_OF_CARDS; i++)
    {
        // 创建事件
        g_hTMFrameSampleThreadExitEvent[i] =  CreateEvent(NULL,TRUE,TRUE,NULL);

        //开启TM采样线程
        g_TMFrameSampleThreadParam[i].pWnd = pWnd;
        g_TMFrameSampleThreadParam[i].Index_Card = i;
        AfxBeginThread(SampleTMFrameThread,&g_TMFrameSampleThreadParam[i],THREAD_PRIORITY_NORMAL,0,0,NULL);
    }
}

// 采样数据的线程
UINT SampleTMFrameThread(LPVOID pParam)
{
    ResetEvent(g_hTMFrameSampleThreadExitEvent[Index_Card]);                    // 不发信号

    // 线程运行标志 和 设备打开标志
    while(g_Receive_Thread_Run & g_DeviceStatus & g_FPGAStatus)
    {
        ...
    }
    
    SetEvent(g_hTMFrameSampleThreadExitEvent[Index_Card]);                      // 发信号

    return 0;
}

void StopServerListenThread()
{
    //等待TM采样线程退出
    for(int i = 0; i < NUM_OF_CARDS;i++)
    {

        if(g_hTMFrameSampleThreadExitEvent[i] != INVALID_HANDLE_VALUE)
        {
            WaitForSingleObject(g_hTMFrameSampleThreadExitEvent[i],-1);         // 发信号状态时继续执行
            CloseHandle(g_hTMFrameSampleThreadExitEvent[i]);
        }
    }
}
```
## HANDLE
[INVALID_HANDLE_VALUE 与 NULL](https://blog.csdn.net/dongchongyang/article/details/9629891)
CreateEvent();函数返回值为 HANDLE  

```cpp
BOOL CloseHandle(
    HANDLE hObject
);
```
参数  
* hObject ：代表一个已打开对象handle。  

返回值  
* TRUE：执行成功；  
* FALSE：执行失败，可以调用GetLastError()获知失败原因。

## CreateEvent、SetEvent、ResetEvent
```cpp
HANDLE CreateEvent(
    LPSECURITY_ATTRIBUTES lpEventAttributes,// 安全属性
    BOOL bManualReset,  // 复位方式 
    BOOL bInitialState, // 初始状态
    LPCTSTRl pName      // 对象名称
);

CEvent::SetEvent
BOOL SetEvent(HANDLE hEvent);   //hEvent表示句柄，返回值：如果操作成功，则返回非零值，否则为0。
```

CreateEvent是一个Windows API函数。它用来创建或打开一个命名的或无名的事件对象。  

**lpEventAttributes[输入]**

一个指向SECURITY_ATTRIBUTES结构的指针，确定返回的句柄是否可被子进程继承。如果lpEventAttributes是NULL，此句柄不能被继承。
Windows NT/2000：lpEventAttributes的结构中的成员为新的事件指定了一个安全符。如果lpEventAttributes是NULL，事件将获得一个默认的安全符。  

**bManualReset[输入]**

指定将事件对象创建成手动复原还是自动复原。

* 如果是TRUE，那么必须用ResetEvent函数来手工将事件的状态复原到无信号状态。

* 如果设置为FALSE，当一个等待线程被释放以后，系统将会自动将事件状态复原为无信号状态。  

**bInitialState[输入]** 

指定事件对象的初始状态。**如果为TRUE，初始状态为有信号状态；** 否则为无信号状态。  

**lpName[输入]**

指定事件的对象的名称，是一个以0结束的字符串指针。名称的字符格式限定在MAX_PATH之内。名字是对大小写敏感的。如果lpName为NULL，将创建一个无名的事件对象。

## WaitForSingleObject
WaitForSingleObject函数用来检测hHandle事件的信号状态。
在某一线程中调用该函数时，线程暂时挂起：
如果在挂起的dwMilliseconds毫秒内，线程所等待的对象变为有信号状态，则该函数立即返回；
如果超时时间已经到达dwMilliseconds毫秒，但hHandle所指向的对象还没有变成有信号状态，函数照样返回。

WaitForSingleObject()等待，直到参数所指定的OBJECT成为发信号状态时才返回，OBJECT可以是EVENT，也可以是其它内核对象。
```cpp
DWORD WINAPI WaitForSingleObject(
__in HANDLE hHandle,
__in DWORD dwMilliseconds
);
```

hHandle [in]对象句柄。  

* 可以指定一系列的对象，如Event、Job、Memory resource notification、Mutex、Process、Semaphore、Thread、Waitable timer等。

dwMilliseconds [in]定时时间间隔，单位为milliseconds（毫秒）

* 如果指定一个非零值，函数处于等待状态直到hHandle标记的对象被触发，或者时间到了。

* 如果dwMilliseconds为0，对象没有被触发信号，函数不会进入一个等待状态，它总是立即返回。

* 如果dwMilliseconds为INFINITE，对象被触发信号后，函数才会返回。